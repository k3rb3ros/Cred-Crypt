#include "include/credentialKey.hpp"

credentialKey::credentialKey(const masterKey* mk): salted_(false), valid_(false), mk_(mk)
{
    if (mk_ != nullptr)
    {   //generate the salt
        if (Random().getBytes((uint8_t*)salt_, SALT_BYTE_SIZE)) { salted_ = true; }

        //attempt to generate the key
        if (this->genKey()) { valid_ = true; }
    }
    else
    {
        throw NullKeyException();
    }

    #ifdef KEY_DEBUG
    debugKey();
    #endif
}

credentialKey::credentialKey(const masterKey* mk, secStr& salt_hex): salted_(false), valid_(false), mk_(mk)
{
    if (hexDecode(salt_hex.byteStr(), (uint8_t*)salt_, (2*SALT_BYTE_SIZE)) != nullptr)
    { salted_ = true; }

    #ifdef KEY_DEBUG
    debugKey();
    #endif
}

//if we have the (correct) salt and a valid ptr to the master key then we can generate the derrived credential key
bool credentialKey::genKey()
{
    bool success = false;

    //the key is generated by xoring the master key with the salt and skein hashing that
    if (salted_ && mk_->isValid())
    {
        //get the master key
        const uint8_t* mk_bytes = mk_->keyBytes();
        //copy it into the key buffer
        memcpy(key_, mk_bytes, KEY_BYTE_SIZE);
        mk_bytes = nullptr;

        //xor the master key with the salt
        for (size_t i=0; i<KEY_WORD_SIZE; ++i)
        {
            key_[i] ^= salt_[i];
        }

        //hash with skein to get the derrived key
        if (skeinHash((uint8_t*)key_, KEY_BYTE_SIZE, (uint8_t*)key_, KEY_BYTE_SIZE))
        {
            success = true;
            valid_ = true;
        }
    }

    return success;
}

bool credentialKey::isValid() const
{
    return valid_;
}

const uint8_t* credentialKey::saltBytes() const
{
    return (salted_ == true) ? (uint8_t*)salt_ : nullptr;
}

//This just returns the bit size of the key (which could vary in the future)
size_t credentialKey::size() const
{
    return KEY_BYTE_SIZE;
}

secStr credentialKey::saltHex() const
{
    unique_ptr<uint8_t[]> salt_hex_bytes =
        unique_ptr<uint8_t[]>(new uint8_t[(2*SALT_BYTE_SIZE)]());

    hexEncode((uint8_t*)salt_, salt_hex_bytes.get(), SALT_BYTE_SIZE); //write the salt hex to its temp buffer

    return secStr(salt_hex_bytes.get(), 2*SALT_BYTE_SIZE);
}

const uint8_t* credentialKey::keyBytes() const
{
    return (salted_ && valid_) ? (uint8_t*)key_ : nullptr;
}

void credentialKey::clearKey()
{
    ::keyBase::clearKey();
    valid_ = false;
}

#ifdef KEY_DEBUG
void credentialKey::debugKey() const
{
    secStr salted_str = salted_ ? secStr("true") : secStr("false");
    secStr valid_str = valid_ ? secStr("true") : secStr("false");
    unique_ptr<uint8_t[]> key_hex(new uint8_t[((2*KEY_BYTE_SIZE)+1)]());
    unique_ptr<uint8_t[]> salt_hex(new uint8_t[((2*SALT_BYTE_SIZE)+1)]());

    hexEncode(key_, key_hex, KEY_BYTE_SIZE);
    hexEncode(salt_, salt_hex, KEY_BYTE_SIZE);

    cout << "credentialKey DEBUG" << endl
    << "{" << endl
    << "\tsalted: " << salted_str << endl
    << "\tvalid: " << valid_str << endl
    << "\tkey: [" << key_hex << endl
    << "\tsalt: [" << salt_hex << endl
    << "\tmaster_key_ptr: " << mk_ << endl
    << "}" << endl;
}
#endif

credentialKey::~credentialKey()
{
    mk_ = nullptr;
    //zero fill the salt
    clearBuff((uint8_t*)salt_, SALT_BYTE_SIZE);
    //key is zero filled by the base class DTOR
}
